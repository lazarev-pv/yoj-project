package tech.ydb.yoj.generator;

import com.google.common.base.CaseFormat;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

/**
 * A recursive structure describing a resulting class which will be generated by the annotation processor
 *
 * @param className name of the target class
 * @param simpleFieldNames names of fields considered as 'simple'
 * @param nestedClasses list of nested classes which describes non-simple fields
 * @param fieldPrefix Let's consider a following source class example:
 *                         <pre>{@code
 *                                                 class RootClass {
 *                                                     NestedClass parent;
 *                                                     class NestedClass {
 *                                                         String child;
 *                                                     }
 *                                                  }
 *                                                 }
 *                                                 </pre>
 *                         <p>Then RootClassFields and nested RootClassFields.Parent will be generated.</p>
 *                         RootClassFields's fieldPrefix will be '' and RootClassFields.Parent's fieldPrefix is 'parent'
 * @param nestLevel nesting level. 0 is a root class.
 */
record TargetClassStructure(
        String className,
        List<String> simpleFieldNames,
        List<TargetClassStructure> nestedClasses,
        String fieldPrefix,
        int nestLevel
) {
    public static TargetClassStructure build(SourceClassStructure sourceClassStructure, String targetClassName) {
        return TargetClassStructure.build(
                sourceClassStructure,
                targetClassName,
                "",
                0
        );
    }

    private static boolean hasOnlyOneField(@Nullable SourceClassStructure field) {

        while (field != null) {
            // We must have only one field ...
            List<FieldInfo> fields = field.fields();
            if (fields.size() != 1) {
                return false;
            }
            // ... and it should be simple ...
            field = field.nestedClasses().get(fields.get(0).type());
            // ... but if it's not, probably a nested class is one-fielded. So we should recursively check it
        }
        return true;
    }

    private static TargetClassStructure build(
            SourceClassStructure sourceClassStructure,
            String className,
            String fieldPrefix,
            int nestLevel
    ) {
        List<String> fields = new ArrayList<>();
        List<TargetClassStructure> nestedClasses = new ArrayList<>();

        for (FieldInfo field : sourceClassStructure.fields()) {
            SourceClassStructure complexField = sourceClassStructure.nestedClasses().get(field.type());

            if (complexField == null || (isIdField(field) && hasOnlyOneField(complexField))) {
                fields.add(field.name());
            } else {
                nestedClasses.add(
                        build(
                                complexField,
                                // className is a field's name in UpperCamel case
                                CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, field.name()),
                                concatFieldNameChain(fieldPrefix, field.name()), // fieldPrefix
                                nestLevel + 1
                        )
                );
            }
        }
        return new TargetClassStructure(className, fields, nestedClasses, fieldPrefix, nestLevel);
    }

    private static boolean isIdField(FieldInfo field) {
        // The better way would be to check that the fields' type implements Entity.Id class.
        // However, since the Entity interface is publicly available,
        // I don't think that renaming of the field will happen
        return field.name().equals("id");
    }

    public static String concatFieldNameChain(String one, String two) {
        if (StringUtils.isEmpty(one)) {
            return two;
        }
        if (StringUtils.isEmpty(two)) {
            return one;
        }
        return one + "." + two;
    }

    /**
     * returns the source code of the class
     */
    public String render(String packageName) {

        String ident = StringUtils.repeat(' ', nestLevel * 4);
        StringBuilder result = new StringBuilder();

        // header
        if (packageName != null) {
            result.append("""
            package %s;
       
            import javax.annotation.processing.Generated;
            
            @Generated("%s")
            """.formatted(packageName, FieldGeneratorAnnotationProcessor.class.getName()));
        }

        // Start class
        result.append(ident).append("public class %s {\n".formatted(className));

        // fields
        simpleFieldNames.stream()
                .map(this::renderField)
                .map(s -> ident + "    " + s + "\n")
                .forEach(result::append);

        // nested classes
        for (TargetClassStructure nestedClass : nestedClasses) {
            result.append(nestedClass.render(null));
        }

        // Close
        result.append(ident).append("}\n");

        return result.toString();
    }

    private String renderField(String simpleFieldName) {
        return "public static final String %s = \"%s\";".formatted(
                CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, simpleFieldName),
                concatFieldNameChain(fieldPrefix, simpleFieldName)
        );
    }
}
